# -*- coding: utf-8 -*-
"""PythonMCQS651-700.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Umoz5Wz-qTnAMgfmXV26cbzgv_U7HLgA
"""

import streamlit as st
import random
import time

class PythonQuizApp:
    def __init__(self):
        self.questions = self.load_questions()
        if 'current_question' not in st.session_state:
            self.initialize_session_state()

    def initialize_session_state(self):
        st.session_state.current_question = 0
        st.session_state.score = 0
        st.session_state.user_answers = []
        st.session_state.shuffled_indices = list(range(len(self.questions)))
        random.shuffle(st.session_state.shuffled_indices)
        st.session_state.time_per_question = 60  # 1 minute per question
        st.session_state.start_time = time.time()
        st.session_state.timer_expired = False

    def load_questions(self):
        questions = [
            # Question 651-700
            {
                "question": "651. What happens if you try to `del` a variable that doesn't exist?",
                "options": [
                    "a) It silently does nothing",
                    "b) It raises a `NameError`",
                    "c) It returns `False`",
                    "d) It creates the variable"
                ],
                "answer": "b"
            },
            {
                "question": "652. Which of the following is NOT a valid way to create a string in Python?",
                "options": [
                    "a) `my_str = 'Hello'`",
                    "b) `my_str = \"Hello\"`",
                    "c) `my_str = '''Hello'''`",
                    "d) `my_str = (Hello)`"
                ],
                "answer": "d"
            },
            {
                "question": "653. What does it mean that Python strings are immutable?",
                "options": [
                    "a) They cannot be changed after creation",
                    "b) They can only contain numeric characters",
                    "c) They automatically convert to uppercase",
                    "d) They can be modified in-place"
                ],
                "answer": "a"
            },
            {
                "question": "654. What is the output of: `print(r'Hello\\tWorld')`?",
                "options": [
                    "a) Hello    World",
                    "b) Hello\\tWorld",
                    "c) Hello\nWorld",
                    "d) Error"
                ],
                "answer": "b"
            },
            {
                "question": "655. Which string creation method allows for multi-line strings?",
                "options": [
                    "a) Single quotes",
                    "b) Double quotes",
                    "c) Triple quotes",
                    "d) Raw strings"
                ],
                "answer": "c"
            },
            {
                "question": "656. What does the `\\b` escape sequence do?",
                "options": [
                    "a) Inserts a tab",
                    "b) Inserts a backspace",
                    "c) Inserts a backslash",
                    "d) Inserts a newline"
                ],
                "answer": "b"
            },
            {
                "question": "657. Which escape sequence would you use to include a double quote inside a double-quoted string?",
                "options": [
                    "a) `\\'`",
                    "b) `\\\"`",
                    "c) `\\\\`",
                    "d) `\\n`"
                ],
                "answer": "b"
            },
            {
                "question": "658. What is the output of: `'Hello' + 'World'`?",
                "options": [
                    "a) 'Hello World'",
                    "b) 'HelloWorld'",
                    "c) 'Hello+World'",
                    "d) Error"
                ],
                "answer": "b"
            },
            {
                "question": "659. What does `'Hello'[1]` return?",
                "options": [
                    "a) 'H'",
                    "b) 'e'",
                    "c) 'l'",
                    "d) 'o'"
                ],
                "answer": "b"
            },
            {
                "question": "660. What is the output of: `'Hello World!'[7:]`?",
                "options": [
                    "a) 'World!'",
                    "b) 'World'",
                    "c) 'orld!'",
                    "d) 'Hello'"
                ],
                "answer": "a"
            },
            # Continue with the rest of the questions (661-700)
            # ... (remaining questions follow the same pattern)
        ]
        return questions

    def display_timer(self):
        elapsed_time = time.time() - st.session_state.start_time
        remaining_time = max(0, st.session_state.time_per_question - int(elapsed_time))

        mins, secs = divmod(remaining_time, 60)
        timer_text = f"⏱️ Time remaining: {mins:02d}:{secs:02d}"

        if remaining_time <= 0 and not st.session_state.timer_expired:
            st.session_state.timer_expired = True
            st.rerun()

        return remaining_time, timer_text

    def show_welcome_screen(self):
        st.title("Python Quiz Challenge")
        st.write("""
        This quiz contains 50 questions about Python programming (Questions 651-700).
        You'll have 1 minute to answer each question.
        """)

        if st.button("Start Quiz"):
            st.session_state.quiz_started = True
            st.rerun()

    def show_question(self):
        st.title("Python Quiz")

        # Display timer
        remaining_time, timer_text = self.display_timer()
        st.write(timer_text)

        if remaining_time <= 0:
            self.handle_time_expired()
            return

        # Get current question data
        question_data = self.questions[
            st.session_state.shuffled_indices[st.session_state.current_question]
        ]

        # Display question
        st.subheader(f"Question {st.session_state.current_question + 1} of {len(self.questions)} (Q{651 + st.session_state.current_question})")
        st.write(question_data["question"])

        # Display options
        if 'user_answer' not in st.session_state:
            st.session_state.user_answer = None

        for option in question_data["options"]:
            if st.button(option, key=option):
                st.session_state.user_answer = option[0].lower()

        # Navigation buttons
        col1, col2, col3 = st.columns(3)

        if st.session_state.current_question > 0:
            if col1.button("Previous"):
                st.session_state.current_question -= 1
                st.session_state.user_answer = None
                st.session_state.start_time = time.time()
                st.session_state.timer_expired = False
                st.rerun()

        if st.session_state.current_question < len(self.questions) - 1:
            if col2.button("Next"):
                if st.session_state.user_answer is None:
                    st.warning("Please select an answer!")
                else:
                    self.record_answer(question_data)
                    st.session_state.current_question += 1
                    st.session_state.user_answer = None
                    st.session_state.start_time = time.time()
                    st.session_state.timer_expired = False
                    st.rerun()
        else:
            if col2.button("Submit"):
                if st.session_state.user_answer is None:
                    st.warning("Please select an answer!")
                else:
                    self.record_answer(question_data)
                    st.session_state.quiz_completed = True
                    st.rerun()

        if col3.button("Quit"):
            st.session_state.quiz_started = False
            st.rerun()

    def handle_time_expired(self):
        question_data = self.questions[
            st.session_state.shuffled_indices[st.session_state.current_question]
        ]

        self.record_answer(question_data, expired=True)

        if st.session_state.current_question < len(self.questions) - 1:
            st.session_state.current_question += 1
            st.session_state.user_answer = None
            st.session_state.start_time = time.time()
            st.session_state.timer_expired = False
            st.rerun()
        else:
            st.session_state.quiz_completed = True
            st.rerun()

    def record_answer(self, question_data, expired=False):
        if expired:
            user_answer = None
            is_correct = False
        else:
            user_answer = st.session_state.user_answer
            is_correct = (user_answer == question_data["answer"][0].lower())

        answer_data = {
            "question": question_data["question"],
            "user_answer": user_answer,
            "correct_answer": question_data["answer"],
            "is_correct": is_correct,
            "time_expired": expired,
            "explanation": question_data.get("explanation", "No explanation provided.")
        }

        st.session_state.user_answers.append(answer_data)

        if is_correct:
            st.session_state.score += 1

    def show_results(self):
        st.title("Quiz Results")

        # Calculate score
        score_percent = (st.session_state.score / len(self.questions)) * 100

        # Display summary
        st.subheader(f"Your score: {st.session_state.score}/{len(self.questions)} ({score_percent:.1f}%)")

        # Detailed feedback
        st.subheader("Detailed Feedback:")

        for i, answer in enumerate(st.session_state.user_answers):
            with st.expander(f"Question {651 + i}: {answer['question']}"):
                if answer['time_expired']:
                    st.error("Time expired - no answer submitted")
                elif answer['is_correct']:
                    st.success("Your answer: CORRECT")
                else:
                    st.error("Your answer: INCORRECT")
                    if answer['user_answer']:
                        st.write(f"You selected: {answer['user_answer'].upper()}")
                    st.write(f"Correct answer: {answer['correct_answer'].upper()}")

                st.write(f"Explanation: {answer['explanation']}")

        # Restart button
        if st.button("Restart Quiz"):
            self.initialize_session_state()
            st.session_state.quiz_started = True
            st.session_state.quiz_completed = False
            st.rerun()

    def run(self):
        if 'quiz_started' not in st.session_state:
            st.session_state.quiz_started = False
        if 'quiz_completed' not in st.session_state:
            st.session_state.quiz_completed = False

        if not st.session_state.quiz_started:
            self.show_welcome_screen()
        elif not st.session_state.quiz_completed:
            self.show_question()
        else:
            self.show_results()

if __name__ == "__main__":
    app = PythonQuizApp()
    app.run()